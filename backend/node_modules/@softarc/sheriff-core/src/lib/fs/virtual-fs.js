"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var _VirtualFs_instances, _VirtualFs_makeOrGet, _VirtualFs_getNode, _VirtualFs_getNodeOrThrow, _VirtualFs_createNode, _VirtualFs_traverseFindFiles, _VirtualFs_absolutePath;
Object.defineProperty(exports, "__esModule", { value: true });
exports.VirtualFs = void 0;
const fs_1 = require("./fs");
const throw_if_null_1 = __importDefault(require("../util/throw-if-null"));
const fs_path_1 = require("../file-info/fs-path");
const os_1 = require("os");
class VirtualFs extends fs_1.Fs {
    constructor() {
        super();
        _VirtualFs_instances.add(this);
        this.findFiles = (path, filename) => {
            const result = __classPrivateFieldGet(this, _VirtualFs_getNode, "f").call(this, path);
            if (!result.exists) {
                throw new Error(`directory ${path} does not exist`);
            }
            else if (result.node.type !== 'directory') {
                throw new Error(`${path} is not a directory`);
            }
            const referenceNode = result.node;
            return __classPrivateFieldGet(this, _VirtualFs_traverseFindFiles, "f").call(this, referenceNode, filename, referenceNode);
        };
        this.createDir = (path) => {
            const node = __classPrivateFieldGet(this, _VirtualFs_makeOrGet, "f").call(this, path, 'directory');
            if (node.type === 'file') {
                throw new Error(`cannot create directory ${path} because it is a file`);
            }
        };
        this.writeFile = (path, contents) => {
            const node = __classPrivateFieldGet(this, _VirtualFs_makeOrGet, "f").call(this, path, 'file');
            if (node.type === 'directory') {
                throw new Error(`cannot write to file ${path} because it is a directory`);
            }
            node.contents = contents;
        };
        this.readFile = (path) => {
            const result = __classPrivateFieldGet(this, _VirtualFs_getNode, "f").call(this, path);
            if (!result.exists) {
                throw new Error(`File ${path} does not exist`);
            }
            else if (result.node.type === 'directory') {
                throw new Error(`cannot read from file ${path} because it is a directory`);
            }
            else {
                return result.node.contents;
            }
        };
        this.removeDir = (path) => {
            const result = __classPrivateFieldGet(this, _VirtualFs_getNode, "f").call(this, path);
            if (!result.exists) {
                throw new Error(`cannot delete directory ${path} because it does not exist`);
            }
            if (result.parent === undefined) {
                throw new Error(`cannot delete root directory`);
            }
            result.parent.children.delete(result.nodeName);
        };
        this.tmpdir = () => '/tmp';
        this.findNearestParentFile = (referenceFile, filename) => {
            const { node } = __classPrivateFieldGet(this, _VirtualFs_getNodeOrThrow, "f").call(this, referenceFile);
            let current = (0, throw_if_null_1.default)(node.parent, `${referenceFile} must have a parent`);
            while (current.parent !== undefined) {
                const searchedNode = Array.from(current.children.values()).find((childNode) => childNode.name === filename && childNode.type === 'file');
                if (searchedNode) {
                    return __classPrivateFieldGet(this, _VirtualFs_absolutePath, "f").call(this, searchedNode);
                }
                current = current.parent;
            }
            throw new Error(`cannot find ${filename} near ${referenceFile}`);
        };
        this.isAbsolute = (path) => path.startsWith('/');
        _VirtualFs_makeOrGet.set(this, (path, type) => {
            const result = __classPrivateFieldGet(this, _VirtualFs_getNode, "f").call(this, path);
            if (result.exists) {
                return result.node;
            }
            if (result.parent === undefined) {
                throw new Error(`could not determine root in ${path}`);
            }
            let node = result.parent;
            for (let i = 0; i < result.restPaths.length; i++) {
                const path = result.restPaths[i];
                const childNode = __classPrivateFieldGet(this, _VirtualFs_instances, "m", _VirtualFs_createNode).call(this, node, i === result.restPaths.length - 1 ? type : 'directory', path);
                node.children.set(path, childNode);
                node = childNode;
            }
            return node;
        });
        _VirtualFs_getNode.set(this, (path) => {
            var _a;
            let node = path.startsWith('/') ? this.root : this.project;
            const paths = path.split('/').filter(Boolean);
            for (let i = 0; i < paths.length; i++) {
                const path = paths[i];
                if (path === '..') {
                    if (node.parent === undefined) {
                        throw new Error('/ has no parent');
                    }
                    node = node.parent;
                }
                else if (path !== '.') {
                    const childNode = node.children.get(path);
                    if (childNode) {
                        node = childNode;
                    }
                    else {
                        return {
                            exists: false,
                            node: undefined,
                            parent: node,
                            restPaths: paths.slice(i),
                        };
                    }
                }
            }
            return {
                exists: true,
                node,
                parent: node.parent,
                nodeName: (_a = paths.at(-1)) !== null && _a !== void 0 ? _a : '',
            };
        });
        _VirtualFs_getNodeOrThrow.set(this, (path) => {
            const response = __classPrivateFieldGet(this, _VirtualFs_getNode, "f").call(this, path);
            if (!response.exists) {
                throw new Error(`file ${path} does not exist`);
            }
            return response;
        });
        _VirtualFs_traverseFindFiles.set(this, (node, filename, referenceNode) => {
            const found = [];
            for (const childNode of node.children.values()) {
                if (childNode.type === 'file' &&
                    childNode.name === filename.toLowerCase()) {
                    found.push(__classPrivateFieldGet(this, _VirtualFs_absolutePath, "f").call(this, childNode));
                }
                if (childNode.type === 'directory') {
                    found.push(...__classPrivateFieldGet(this, _VirtualFs_traverseFindFiles, "f").call(this, childNode, filename, referenceNode));
                }
            }
            return found;
        });
        _VirtualFs_absolutePath.set(this, (node) => {
            const paths = [];
            let current = node;
            while (current.parent !== undefined && current !== this.root) {
                paths.push(current.name);
                current = current.parent;
            }
            return (0, fs_path_1.toFsPath)('/' + paths.reverse().join('/'));
        });
        this.print = (node, indent = 0) => {
            if (node === undefined) {
                console.log('[root]');
                this.print(this.root, indent + 2);
                return;
            }
            for (const child of node.children.keys()) {
                const childNode = node.children.get(child);
                console.log(`${' '.repeat(indent)}${(childNode === null || childNode === void 0 ? void 0 : childNode.type) === 'directory' ? '[' + child + ']' : child}`);
                this.print(node.children.get(child), indent + 2);
            }
        };
        this.cwd = () => '/project';
        this.init();
    }
    init() {
        this.root = {
            parent: undefined,
            children: new Map(),
            contents: '',
            type: 'directory',
            name: 'root',
        };
        this.project = {
            parent: this.root,
            children: new Map(),
            contents: '',
            type: 'directory',
            name: 'project',
        };
        this.root.children.set('project', this.project);
    }
    exists(path) {
        return __classPrivateFieldGet(this, _VirtualFs_getNode, "f").call(this, path).exists;
    }
    appendFile(filename, contents) {
        const node = __classPrivateFieldGet(this, _VirtualFs_makeOrGet, "f").call(this, filename, 'file');
        if (node.contents === '') {
            node.contents = contents;
        }
        else {
            node.contents = node.contents + os_1.EOL + contents;
        }
    }
    reset() {
        this.init();
    }
    split(path) {
        return path.split('/');
    }
    isFile(path) {
        const node = __classPrivateFieldGet(this, _VirtualFs_getNodeOrThrow, "f").call(this, path);
        return node.node.type === 'file';
    }
}
exports.VirtualFs = VirtualFs;
_VirtualFs_makeOrGet = new WeakMap(), _VirtualFs_getNode = new WeakMap(), _VirtualFs_getNodeOrThrow = new WeakMap(), _VirtualFs_traverseFindFiles = new WeakMap(), _VirtualFs_absolutePath = new WeakMap(), _VirtualFs_instances = new WeakSet(), _VirtualFs_createNode = function _VirtualFs_createNode(parent, type, name) {
    return {
        parent,
        children: new Map(),
        contents: '',
        type,
        name,
    };
};
const virtualFs = new VirtualFs();
exports.default = virtualFs;
//# sourceMappingURL=virtual-fs.js.map